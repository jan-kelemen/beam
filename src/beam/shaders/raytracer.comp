#version 460

layout (local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConsts {
    vec3 cameraPosition;
} pc;

layout(rgba32f, set = 0, binding = 0) uniform image2D image;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

vec3 rayAt(Ray r, float t) {
    return r.origin + t * r.direction;
}

struct HitRecord
{
    vec3 p;
    vec3 normal;
    float t;
};

struct Interval
{
    float min;
    float max;
};

struct Sphere
{
    vec3 center;
    float radius;
};

bool hitSphere(Sphere s, Ray r, Interval inter, inout HitRecord rec) {
    vec3 oc = s.center - r.origin;

    float a = dot(r.direction, r.direction);
    float h = dot(r.direction, oc);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = h*h - a*c;

    if (discriminant < 0) {
        return false;
    }
    
    float sqrtd = sqrt(discriminant);

    float root = (h - sqrtd) / a;

    if (root <= inter.min || inter.max <= root) {
        root = (h + sqrtd) / a;
        if (root <= inter.min || inter.max <= root) {
            return false;
        }
    }

    rec.t = root;
    rec.p = rayAt(r, rec.t);
    rec.normal = (rec.p - s.center) / s.radius;

    return true;
}

vec4 rayColor(Ray r) {
    Sphere s = Sphere(vec3(0, 0, -1), 0.5);

    Interval inter = Interval(0, 1.0 / 0.0);

    HitRecord rec;
    if (hitSphere(s, r, inter, rec)) {
        vec3 N = normalize(rayAt(r, rec.t) - vec3(0, 0, -1));
        vec4 color = vec4(N + vec3(1), 1.0);

        return 0.5 * color;
    }

    vec3 normDirection = normalize(r.direction);
    float alpha = 0.5 * (normDirection.y + 1.0);
    return (1.0 - alpha) * vec4(1) + alpha * vec4(0.5, 0.7, 1.0, 1.0);
}

void main() 
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(image);
    float aspectRatio = float(imageSize.x) / imageSize.y;

    float focalLength = 1.0;
    float viewportHeight = 2.0;
    float viewportWidth = viewportHeight * aspectRatio;

    vec3 viewportU = vec3(viewportWidth, 0, 0);
    vec3 viewportV = vec3(0, -viewportHeight, 0);

    vec3 pixelDeltaU = viewportU / imageSize.x;
    vec3 pixelDeltaV = viewportV / imageSize.y;

    vec3 viewportUpperLeft = pc.cameraPosition
                             - vec3(0, 0, focalLength) - viewportU / 2 - viewportV /2;

    vec3 pixel00 = viewportUpperLeft + 0.5 * (pixelDeltaU + pixelDeltaV);


    if(texelCoord.x < imageSize.x && texelCoord.y < imageSize.y)
    {
        vec3 pixelCenter = pixel00 + (texelCoord.x * pixelDeltaU) + (texelCoord.y * pixelDeltaV);

        vec3 rayDirection = pixelCenter - pc.cameraPosition;
        Ray r = Ray(pc.cameraPosition, rayDirection);
    
        imageStore(image, texelCoord, rayColor(r));
    }
}